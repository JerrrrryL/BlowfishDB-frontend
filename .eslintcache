[{"C:\\Users\\Jerry\\blowfish-interface\\src\\index.js":"1","C:\\Users\\Jerry\\blowfish-interface\\src\\reportWebVitals.js":"2","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\App.js":"3","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.react.js":"4","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.min.js":"5","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Panel.js":"6","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\PolicyGraph.js":"7","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Schema.js":"8","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\AnalystPanel.js":"9","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\analystTable.js":"10"},{"size":571,"mtime":1613969969511,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":499162500000,"results":"13","hashOfConfig":"12"},{"size":3763,"mtime":1615147834955,"results":"14","hashOfConfig":"12"},{"size":2080,"mtime":1608195814650,"results":"15","hashOfConfig":"12"},{"size":590816,"mtime":1608195906087,"results":"16","hashOfConfig":"12"},{"size":86187,"mtime":1629150151453,"results":"17","hashOfConfig":"12"},{"size":13914,"mtime":1629149651531,"results":"18","hashOfConfig":"12"},{"size":844,"mtime":1610251305128,"results":"19","hashOfConfig":"12"},{"size":48022,"mtime":1629016801927,"results":"20","hashOfConfig":"12"},{"size":14834,"mtime":1629016541745,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"s7d6vn",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"24"},"C:\\Users\\Jerry\\blowfish-interface\\src\\index.js",[],["45","46"],"C:\\Users\\Jerry\\blowfish-interface\\src\\reportWebVitals.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\App.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.react.js",["47"],"ï»¿/*\r\nCanvasJS React Charts - https://canvasjs.com/\r\nCopyright 2020 fenopix\r\n\r\n--------------------- License Information --------------------\r\nCanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\r\nhttps://canvasjs.com/license/\r\n\r\n*/\r\nvar React = require('react');\r\nvar CanvasJS = require('./canvasjs.min');\r\nCanvasJS = CanvasJS.Chart ? CanvasJS : window.CanvasJS;\r\n\r\nclass CanvasJSChart extends React.Component {\r\n\tstatic _cjsContainerId = 0\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.options = props.options ? props.options : {};\r\n\t\tthis.containerProps = props.containerProps ? props.containerProps : { width: \"100%\", position: \"relative\" };\r\n\t\tthis.containerProps.height = props.containerProps && props.containerProps.height ? props.containerProps.height : this.options.height ? this.options.height + \"px\" : \"400px\";\r\n\t\tthis.chartContainerId = \"canvasjs-react-chart-container-\" + CanvasJSChart._cjsContainerId++;\r\n\t}\r\n\tcomponentDidMount() {\r\n\t\t//Create Chart and Render\t\t\r\n\t\tthis.chart = new CanvasJS.Chart(this.chartContainerId, this.options);\r\n\t\tthis.chart.render();\r\n\r\n\t\tif (this.props.onRef)\r\n\t\t\tthis.props.onRef(this.chart);\r\n\t}\r\n\tshouldComponentUpdate(nextProps, nextState) {\r\n\t\t//Check if Chart-options has changed and determine if component has to be updated\r\n\t\treturn !(nextProps.options === this.options);\r\n\t}\r\n\tcomponentDidUpdate() {\r\n\t\t//Update Chart Options & Render\r\n\t\tthis.chart.options = this.props.options;\r\n\t\tthis.chart.render();\r\n\t}\r\n\tcomponentWillUnmount() {\r\n\t\t//Destroy chart and remove reference\r\n\t\tthis.chart.destroy();\r\n\t\tif (this.props.onRef)\r\n\t\t\tthis.props.onRef(undefined);\r\n\t}\r\n\trender() {\r\n\t\t//return React.createElement('div', { id: this.chartContainerId, style: this.containerProps });\t\t\r\n\t\treturn <div id={this.chartContainerId} style={this.containerProps} />\r\n\t}\r\n}\r\n\r\nvar CanvasJSReact = {\r\n\tCanvasJSChart: CanvasJSChart,\r\n\tCanvasJS: CanvasJS\r\n};\r\n\r\nexport default CanvasJSReact;","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.min.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Panel.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\PolicyGraph.js",["48"],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Schema.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\AnalystPanel.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\analystTable.js",["49","50"],"import React from 'react'\r\nimport styled from 'styled-components'\r\nimport { useTable, useRowSelect } from 'react-table'\r\nimport { Grid } from 'semantic-ui-react';\r\nimport CanvasJSReact from './canvasjs.react';\r\n\r\nconst Styles = styled.div`\r\n  padding: 1rem;\r\n\r\n  table {\r\n    border-spacing: 0;\r\n    border: 1px solid black;\r\n    width: 570px;\r\n    \r\n    tr {\r\n      :last-child {\r\n        td {\r\n          border-bottom: 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    th,\r\n    td {\r\n      margin: 0;\r\n      padding: 0.3rem;\r\n      border-bottom: 1px solid black;\r\n      border-right: 1px solid black;\r\n\r\n      :last-child {\r\n        border-right: 0;\r\n      }\r\n    }\r\n  }\r\n`\r\n\r\nconst IndeterminateCheckbox = React.forwardRef(\r\n    ({ indeterminate, ...rest }, ref) => {\r\n        const defaultRef = React.useRef()\r\n        const resolvedRef = ref || defaultRef\r\n\r\n        React.useEffect(() => {\r\n            resolvedRef.current.indeterminate = indeterminate\r\n        }, [resolvedRef, indeterminate])\r\n\r\n        return (\r\n            <>\r\n                <input type=\"checkbox\" ref={resolvedRef} {...rest} />\r\n            </>\r\n        )\r\n    }\r\n)\r\n\r\nfunction computeGranularity(queryGranularity, lowerBound, upperBound) {\r\n    // console.log('Parameters:', queryGranularity, lowerBound, upperBound)\r\n    let selectedGranu = queryGranularity;\r\n    // sanity check, assign defaut to be 1 if null\r\n    if (selectedGranu === null) {\r\n        selectedGranu = 1\r\n    }\r\n    let granuLabels = [];\r\n    let numEle = Math.ceil((upperBound - lowerBound + 1) / selectedGranu)\r\n    // console.log('this is the number of elements', numEle)\r\n    for (let i = 0; i < numEle; ++i) {\r\n        granuLabels = granuLabels.concat({\r\n            lower: lowerBound + i * selectedGranu,\r\n            upper: lowerBound + (i + 1) * selectedGranu\r\n        })\r\n    }\r\n    // console.log('This is the computed granularity at the end: ', granuLabels)\r\n    return granuLabels;\r\n}\r\n\r\nfunction toggleDataSeries(e) {\r\n    if (typeof (e.dataSeries.visible) === \"undefined\" || e.dataSeries.visible) {\r\n        e.dataSeries.visible = false;\r\n    }\r\n    else {\r\n        e.dataSeries.visible = true;\r\n    }\r\n    this.chart.render();\r\n}\r\n\r\nfunction displayPlots(attrNames, noisyCounts, ranges, granus, workloads) {\r\n    var CanvasJSChart = CanvasJSReact.CanvasJSChart;\r\n    let dataOptions = [];\r\n    for (let i = 0; i < noisyCounts.length; ++i) {\r\n        // console.log(noisyCounts[i], ranges[i], granus[i])\r\n        let noisyAnsPoints = [];\r\n        let noisyAnsPoints1 = [];\r\n        const noisyCount = noisyCounts[i].data;\r\n        const granularity = granus[i];\r\n        const lower = ranges[i].lower;\r\n        const upper = ranges[i].upper;\r\n        // let noisyCounts = this.state.noisyRes;\r\n        const granularityLabels = computeGranularity(granularity, lower, upper);\r\n        if (Array.isArray(noisyCount)) {\r\n            const numPredicates = noisyCount.length;\r\n            if (numPredicates === granularityLabels.length) {\r\n                for (let j = 0; j < numPredicates; ++j) {\r\n                    let y = 0;\r\n                    const x = (granularityLabels[j].lower + granularityLabels[j].upper) / 2\r\n                    if (noisyCount[j] >= 0) {\r\n                        y = noisyCount[j];\r\n                    }\r\n                    noisyAnsPoints = noisyAnsPoints.concat(\r\n                        {\r\n                            x: x,\r\n                            // label: granularityLabels[i].lower.toString() + \"<=\" + attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                            y: y\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n        } else {\r\n            const noisyCount1 = noisyCount.attr1;\r\n            const noisyCount2 = noisyCount.attr2;\r\n            const numPredicates = noisyCount1.length;\r\n            for (let i = 0; i < numPredicates; ++i) {\r\n                let y = 0;\r\n                let y1 = 0;\r\n                const x = (granularityLabels[i].lower + granularityLabels[i].upper) / 2\r\n                if (noisyCount1[i] >= 0) {\r\n                    y = noisyCount1[i];\r\n                }\r\n                if (noisyCount2[i] >= 0) {\r\n                    y1 = noisyCount2[i];\r\n                }\r\n                noisyAnsPoints = noisyAnsPoints.concat(\r\n                    {\r\n                        x: x,\r\n                        // label: attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                        y: y\r\n                    }\r\n                )\r\n                noisyAnsPoints1 = noisyAnsPoints1.concat(\r\n                    {\r\n                        x: x,\r\n                        // label: attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                        y: y1\r\n                    }\r\n                )\r\n            }\r\n        }\r\n        // console.log(numPredicates)\r\n        // console.log('This is the granularity labels:', granularityLabels)\r\n        // console.log('This is the granularity labels length:', this.state.noisyRes)\r\n        console.log('This is the datapoints', noisyAnsPoints)\r\n        let options = {\r\n            height: 250,\r\n            width: 275,\r\n            animationEnabled: true,\r\n            exportEnabled: true,\r\n            theme: \"light2\", //\"light1\", \"dark1\", \"dark2\"\r\n            title: {\r\n                text: 'Noisy Counts',\r\n                fontSize: 15\r\n            },\r\n            axisX: {\r\n                labelAngle: 50,\r\n                minimum: lower,\r\n                maximum: upper\r\n            },\r\n            axisY: {\r\n                includeZero: true\r\n            },\r\n            toolTip: {\r\n                shared: true\r\n            },\r\n            legend: {\r\n                cursor: \"pointer\",\r\n                itemclick: toggleDataSeries\r\n            },\r\n            data: [{\r\n                type: \"column\", //change type to bar, line, area, pie, etc\r\n                //indexLabel: \"{y}\", //Shows y value on all Data Points\r\n                name: attrNames[i].attrName,\r\n                showInLegend: true,\r\n                indexLabelFontColor: \"#5A5757\",\r\n                indexLabelPlacement: \"outside\",\r\n                color: \"#6D78AD\",\r\n                dataPoints: noisyAnsPoints\r\n            }]\r\n        }\r\n\r\n        console.log(\"This is the workloads\", workloads);\r\n        if (workloads[i] === '1D-Histogram') {\r\n            options.title.text = 'Noisy Counts (Histogram)'\r\n        } else if (workloads[i] === '1D-Cumulative') {\r\n            options.title.text = 'Noisy Counts (Cumulative)'\r\n        } else {\r\n            // This is the 2 dimensional case\r\n            options.title.text = 'Noisy Counts (2D Histogram)'\r\n            options.data = [\r\n                {\r\n                    type: \"column\",\r\n                    name: \"Female\",  // hardcoded here, need to be changed later\r\n                    showInLegend: true,\r\n                    yValueFormatString: \"#,##0.##\",\r\n                    dataPoints: noisyAnsPoints\r\n                },\r\n                {\r\n                    type: \"column\",\r\n                    name: \"Male\",\r\n                    showInLegend: true,\r\n                    yValueFormatString: \"#,##0.##\",\r\n                    dataPoints: noisyAnsPoints1\r\n                }\r\n            ]\r\n        }\r\n        dataOptions = dataOptions.concat(options);\r\n    }\r\n    console.log(dataOptions);\r\n    if (dataOptions.length === 1) {\r\n        return (\r\n            <Grid.Column style={{ width: 300 }}>\r\n                <div className=\"analystNoisyResult\">\r\n                    <CanvasJSChart options={dataOptions[0]}\r\n                    /* onRef={ref => this.chart = ref} */\r\n                    />\r\n                    {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                </div>\r\n            </Grid.Column>\r\n        )\r\n    } else if (dataOptions.length === 2) {\r\n        return (\r\n            <Grid>\r\n                <Grid.Column style={{ width: 300 }}>\r\n                    <div className=\"analystNoisyResult\">\r\n                        <CanvasJSChart options={dataOptions[0]}\r\n                        /* onRef={ref => this.chart = ref} */\r\n                        />\r\n                        {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                    </div>\r\n                </Grid.Column>\r\n                <Grid.Column style={{ width: 300 }}>\r\n                    <div className=\"analystNoisyResult\">\r\n                        <CanvasJSChart options={dataOptions[1]}\r\n                        /* onRef={ref => this.chart = ref} */\r\n                        />\r\n                        {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                    </div>\r\n                </Grid.Column>\r\n            </Grid>\r\n        )\r\n    } else if (dataOptions.length > 2) {\r\n        alert(\"Please select at most 2 records\")\r\n    }\r\n}\r\n\r\nfunction ConstructTable({ columns, data, counts }) {\r\n    // Use the state and functions returned from useTable to build your UI\r\n    const {\r\n        getTableProps,\r\n        getTableBodyProps,\r\n        headerGroups,\r\n        rows,\r\n        prepareRow,\r\n        selectedFlatRows,\r\n        state: { selectedRowIds },\r\n    } = useTable(\r\n        {\r\n            columns,\r\n            data,\r\n        },\r\n        useRowSelect,\r\n        hooks => {\r\n            hooks.visibleColumns.push(columns => [\r\n                // Let's make a column for selection\r\n                {\r\n                    id: 'selection',\r\n                    // The header can use the table's getToggleAllRowsSelectedProps method\r\n                    // to render a checkbox\r\n                    Header: ({ getToggleAllRowsSelectedProps }) => (\r\n                        <div>\r\n                            <IndeterminateCheckbox {...getToggleAllRowsSelectedProps()} />\r\n                        </div>\r\n                    ),\r\n                    // The cell can use the individual row's getToggleRowSelectedProps method\r\n                    // to the render a checkbox\r\n                    Cell: ({ row }) => (\r\n                        <div>\r\n                            <IndeterminateCheckbox {...row.getToggleRowSelectedProps()} />\r\n                        </div>\r\n                    ),\r\n                },\r\n                ...columns,\r\n            ])\r\n        }\r\n    )\r\n\r\n    // console.log(selectedRowIds)\r\n    // variables for graphs\r\n    let noisyCountsIndex = [];\r\n    let noisyCounts = [];\r\n    let ranges = [];\r\n    let granu = [];\r\n    let workloads = [];\r\n    let attrNames = []\r\n    selectedFlatRows.map(\r\n        d => {\r\n            noisyCountsIndex = noisyCountsIndex.concat(d.original.col1)\r\n        }\r\n    )\r\n    for (let i = 0; i < noisyCountsIndex.length; ++i) {\r\n        attrNames = attrNames.concat({\r\n            attrName: counts[noisyCountsIndex[i] - 1].attrName\r\n        })\r\n        noisyCounts = noisyCounts.concat({\r\n            data: counts[noisyCountsIndex[i] - 1].data\r\n        })\r\n        ranges = ranges.concat({\r\n            lower: counts[noisyCountsIndex[i] - 1].range.lower,\r\n            upper: counts[noisyCountsIndex[i] - 1].range.upper\r\n        })\r\n        granu = granu.concat(counts[noisyCountsIndex[i] - 1].granularity)\r\n        workloads = workloads.concat(counts[noisyCountsIndex[i] - 1].workload)\r\n    }\r\n    return (\r\n        <Grid columns={1}>\r\n            <Grid.Row className=\"privacyBudget\">\r\n                The query results will be summarized in the table below\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultTable\">\r\n                <Styles>\r\n                    <table {...getTableProps()}>\r\n                        <thead>\r\n                            {headerGroups.map(headerGroup => (\r\n                                <tr {...headerGroup.getHeaderGroupProps()}>\r\n                                    {headerGroup.headers.map(column => (\r\n                                        <th {...column.getHeaderProps()}>{column.render('Header')}</th>\r\n                                    ))}\r\n                                </tr>\r\n                            ))}\r\n                        </thead>\r\n                        <tbody {...getTableBodyProps()}>\r\n                            {rows.slice(0, 10).map((row, i) => {\r\n                                prepareRow(row)\r\n                                return (\r\n                                    <tr {...row.getRowProps()}>\r\n                                        {row.cells.map(cell => {\r\n                                            return <td {...cell.getCellProps()}>{cell.render('Cell')}</td>\r\n                                        })}\r\n                                    </tr>\r\n                                )\r\n                            })}\r\n                        </tbody>\r\n                    </table>\r\n                </Styles>\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultComparisonDesc\">\r\n                Please select at most 2 records for comparison\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultComparison\">\r\n                {displayPlots(attrNames, noisyCounts, ranges, granu, workloads)}\r\n            </Grid.Row>\r\n        </Grid>\r\n    )\r\n}\r\n\r\nfunction Table(dataRecord) {\r\n    const record = dataRecord.dataRecord;\r\n    let data = [];\r\n    for (let i = 0; i < record.length; ++i) {\r\n        data = data.concat({\r\n            col1: record[i].index,\r\n            col2: record[i].attrName,\r\n            col3: record[i].workload,\r\n            col4: record[i].granularity,\r\n            col5: record[i].alpha,\r\n            col6: record[i].beta,\r\n            col7: record[i].epsilon,\r\n            col8: record[i].remainingBudget,\r\n        })\r\n    }\r\n\r\n    const columns = [\r\n        {\r\n            Header: 'Query Ind.',\r\n            accessor: 'col1', // accessor is the \"key\" in the data\r\n        },\r\n        {\r\n            Header: 'Attribute',\r\n            accessor: 'col2', // accessor is the \"key\" in the data\r\n        },\r\n        {\r\n            Header: 'Workload Type',\r\n            accessor: 'col3',\r\n        },\r\n        {\r\n            Header: 'Granularity',\r\n            accessor: 'col4',\r\n        },\r\n        {\r\n            Header: 'Alpha',\r\n            accessor: 'col5',\r\n        },\r\n        {\r\n            Header: 'Beta',\r\n            accessor: 'col6',\r\n        },\r\n        {\r\n            Header: 'Privacy Cost',\r\n            accessor: 'col7',\r\n        },\r\n        {\r\n            Header: 'Remaining Budget',\r\n            accessor: 'col8',\r\n        }\r\n    ]\r\n    return (\r\n        <ConstructTable columns={columns} data={data} counts={record} />\r\n    )\r\n}\r\n\r\n\r\nexport default Table;",{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","severity":1,"message":"56","line":1,"column":1,"nodeType":"57","messageId":"58","fix":"59"},{"ruleId":"60","severity":1,"message":"61","line":8,"column":5,"nodeType":"62","messageId":"63","endLine":10,"endColumn":6},{"ruleId":"64","severity":1,"message":"65","line":260,"column":18,"nodeType":"66","messageId":"67","endLine":260,"endColumn":32},{"ruleId":"68","severity":1,"message":"69","line":301,"column":11,"nodeType":"70","messageId":"71","endLine":301,"endColumn":13},"no-native-reassign",["72"],"no-negated-in-lhs",["73"],"unicode-bom","Unexpected Unicode BOM (Byte Order Mark).","Program","unexpected",{"range":"74","text":"75"},"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-unused-vars","'selectedRowIds' is assigned a value but never used.","Identifier","unusedVar","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation",[-1,0],""]