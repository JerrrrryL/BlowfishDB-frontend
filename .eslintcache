[{"C:\\Users\\Jerry\\blowfish-interface\\src\\index.js":"1","C:\\Users\\Jerry\\blowfish-interface\\src\\reportWebVitals.js":"2","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\App.js":"3","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.react.js":"4","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.min.js":"5","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Panel.js":"6","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\PolicyGraph.js":"7","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Schema.js":"8","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\AnalystPanel.js":"9","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\analystTable.js":"10"},{"size":571,"mtime":1613969969511,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":499162500000,"results":"13","hashOfConfig":"12"},{"size":3763,"mtime":1615147834955,"results":"14","hashOfConfig":"12"},{"size":2080,"mtime":1608195814650,"results":"15","hashOfConfig":"12"},{"size":590816,"mtime":1608195906087,"results":"16","hashOfConfig":"12"},{"size":85551,"mtime":1629063790010,"results":"17","hashOfConfig":"12"},{"size":12347,"mtime":1615361309888,"results":"18","hashOfConfig":"12"},{"size":844,"mtime":1610251305128,"results":"19","hashOfConfig":"12"},{"size":48022,"mtime":1629016801927,"results":"20","hashOfConfig":"12"},{"size":14834,"mtime":1629016541745,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"s7d6vn",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"24"},"C:\\Users\\Jerry\\blowfish-interface\\src\\index.js",[],["46","47"],"C:\\Users\\Jerry\\blowfish-interface\\src\\reportWebVitals.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\App.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.react.js",["48"],"ï»¿/*\r\nCanvasJS React Charts - https://canvasjs.com/\r\nCopyright 2020 fenopix\r\n\r\n--------------------- License Information --------------------\r\nCanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\r\nhttps://canvasjs.com/license/\r\n\r\n*/\r\nvar React = require('react');\r\nvar CanvasJS = require('./canvasjs.min');\r\nCanvasJS = CanvasJS.Chart ? CanvasJS : window.CanvasJS;\r\n\r\nclass CanvasJSChart extends React.Component {\r\n\tstatic _cjsContainerId = 0\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.options = props.options ? props.options : {};\r\n\t\tthis.containerProps = props.containerProps ? props.containerProps : { width: \"100%\", position: \"relative\" };\r\n\t\tthis.containerProps.height = props.containerProps && props.containerProps.height ? props.containerProps.height : this.options.height ? this.options.height + \"px\" : \"400px\";\r\n\t\tthis.chartContainerId = \"canvasjs-react-chart-container-\" + CanvasJSChart._cjsContainerId++;\r\n\t}\r\n\tcomponentDidMount() {\r\n\t\t//Create Chart and Render\t\t\r\n\t\tthis.chart = new CanvasJS.Chart(this.chartContainerId, this.options);\r\n\t\tthis.chart.render();\r\n\r\n\t\tif (this.props.onRef)\r\n\t\t\tthis.props.onRef(this.chart);\r\n\t}\r\n\tshouldComponentUpdate(nextProps, nextState) {\r\n\t\t//Check if Chart-options has changed and determine if component has to be updated\r\n\t\treturn !(nextProps.options === this.options);\r\n\t}\r\n\tcomponentDidUpdate() {\r\n\t\t//Update Chart Options & Render\r\n\t\tthis.chart.options = this.props.options;\r\n\t\tthis.chart.render();\r\n\t}\r\n\tcomponentWillUnmount() {\r\n\t\t//Destroy chart and remove reference\r\n\t\tthis.chart.destroy();\r\n\t\tif (this.props.onRef)\r\n\t\t\tthis.props.onRef(undefined);\r\n\t}\r\n\trender() {\r\n\t\t//return React.createElement('div', { id: this.chartContainerId, style: this.containerProps });\t\t\r\n\t\treturn <div id={this.chartContainerId} style={this.containerProps} />\r\n\t}\r\n}\r\n\r\nvar CanvasJSReact = {\r\n\tCanvasJSChart: CanvasJSChart,\r\n\tCanvasJS: CanvasJS\r\n};\r\n\r\nexport default CanvasJSReact;","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\canvasjs.min.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Panel.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\PolicyGraph.js",["49"],"import React, { Component } from 'react'\r\nimport CytoscapeComponent from 'react-cytoscapejs'\r\nimport { Grid } from 'semantic-ui-react'\r\n\r\n// For a given (categorical) policy, visualize the policy graph for it\r\n\r\nclass PolicyGraph extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n    state = {\r\n        w: 0,\r\n        h: 0,\r\n        subGraph: false,\r\n    }\r\n\r\n    componentDidMount = () => {\r\n        this.setState({\r\n            w: window.innerWidth,\r\n            h: window.innerHeight\r\n        })\r\n        this.setUpListeners()\r\n    }\r\n\r\n    setUpListeners = () => {\r\n        this.cy.on('click', 'node', (event) => {\r\n            console.log(event.target)\r\n        })\r\n    }\r\n\r\n    render() {\r\n        let x1 = 0;\r\n        let y1 = 30;\r\n        let w = 280;\r\n        let h = 280;\r\n        let nodesEdges = []\r\n        // this is the case when we are dealing with categorical data\r\n        if (this.props.attrType === 'categorical') {\r\n            // assign values inside the domain to be nodes\r\n            for (let i = 0; i < this.props.attributeDomain.length; ++i) {\r\n                // console.log(this.props.attributeDomain[i])\r\n                let curNode = {\r\n                    data: { id: this.props.attributeDomain[i].value, label: this.props.attributeDomain[i].label },\r\n                    position: { x: 10, y: 50 },\r\n                    style: {\r\n                        'background-color': '#d4d4d4',\r\n                        \"text-valign\": \"center\",\r\n                        \"text-halign\": \"center\"\r\n                    }\r\n                }\r\n                nodesEdges = nodesEdges.concat(curNode)\r\n            }\r\n            // assign values in the policy set to be edges\r\n            // Note that this will be a clique in the contained set\r\n            // console.log(this.props.sensitiveSet)\r\n            if (this.props.sensitiveSet !== null) {\r\n                for (let i = 0; i < this.props.sensitiveSet.length; ++i) {\r\n                    for (let j = i + 1; j < this.props.sensitiveSet.length; ++j) {\r\n                        let curEdge = {\r\n                            data: { source: this.props.sensitiveSet[i].value, target: this.props.sensitiveSet[j].value },\r\n                            style: {\r\n                                'line-color': '#000000',\r\n                                'width': 1\r\n                            }\r\n                        }\r\n                        nodesEdges = nodesEdges.concat(curEdge)\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // when attribute type is numerical\r\n            // console.log(this.props.attributeDomain)\r\n            // console.log(this.props.attrThreshold)\r\n            const granularity = this.props.granularity.value;\r\n            // console.log('This is the granularity:', granularity)\r\n            const lowerBound = this.props.attributeDomain.domain[0];\r\n            const upperBound = this.props.attributeDomain.domain[1];\r\n            let subGraph = false;\r\n            let displayNodes = 5;\r\n            if (Math.ceil((upperBound - lowerBound) / granularity) < displayNodes) {\r\n                displayNodes = Math.ceil((upperBound - lowerBound) / granularity)\r\n            } else {\r\n                subGraph = true\r\n            }\r\n            const attrName = this.props.attributeDomain.attrName;\r\n            let previousBound = lowerBound + granularity; // the lower bound for each node in the policy graph\r\n            // set the default granularity to display here\r\n            // add nodes to the graph\r\n            for (let i = 0; i < displayNodes; ++i) {\r\n                let curNode = null;\r\n                if (i === 0) {\r\n                    curNode = {\r\n                        data: {\r\n                            // id cannot be a tuple\r\n                            id: i,\r\n                            label: attrName + \"<\" + previousBound\r\n                        },\r\n                        position: { x: 200, y: 50 },\r\n                        style: {\r\n                            'background-color': '#d4d4d4',\r\n                            \"text-valign\": \"center\",\r\n                            \"text-halign\": \"center\",\r\n                            \"font-size\": 12,\r\n                        }\r\n                    }\r\n                } else if (i === displayNodes - 1) {\r\n                    curNode = {\r\n                        data: {\r\n                            id: i,\r\n                            label: previousBound + \"<=\" + attrName\r\n                        },\r\n                        position: { x: 150, y: 50 },\r\n                        style: {\r\n                            'background-color': '#d4d4d4',\r\n                            \"text-valign\": \"center\",\r\n                            \"text-halign\": \"center\",\r\n                            \"font-size\": 12,\r\n                        }\r\n                    }\r\n                } else {\r\n                    let tempUpper = previousBound + granularity;\r\n                    curNode = {\r\n                        data: {\r\n                            id: i,\r\n                            label: previousBound + \"<=\" + attrName + \"<\" + tempUpper\r\n                        },\r\n                        position: { x: 200, y: 50 },\r\n                        style: {\r\n                            'background-color': '#d4d4d4',\r\n                            \"text-valign\": \"center\",\r\n                            \"text-halign\": \"center\",\r\n                            \"font-size\": 12,\r\n                        }\r\n                    }\r\n                }\r\n                nodesEdges = nodesEdges.concat(curNode)\r\n                if (i !== 0) {\r\n                    previousBound += granularity;\r\n                }\r\n            }\r\n\r\n            // note that nodes are sorted\r\n            let threshold = 0;\r\n            let displayDP = false;\r\n            if (this.props.attrThreshold !== null) {\r\n                threshold = this.props.attrThreshold.value;\r\n            } else {\r\n                threshold = Number.MAX_SAFE_INTEGER;\r\n                displayDP = true;\r\n            }\r\n            let degree = Math.ceil(threshold / granularity);\r\n            // console.log(degree)\r\n            for (let i = 0; i < displayNodes; ++i) {\r\n                // draw edges between nodes based on thresholds\r\n                for (let j = i + 1; j < displayNodes; ++j) {\r\n                    if (j - i <= degree) {\r\n                        let curEdge = {\r\n                            data: { source: i, target: j },\r\n                            style: {\r\n                                'line-color': '#000000',\r\n                                'width': 1\r\n                            }\r\n                        }\r\n                        nodesEdges = nodesEdges.concat(curEdge)\r\n                    }\r\n                }\r\n            }\r\n            let layout = {\r\n                name: 'circle',\r\n\r\n                fit: false, // whether to fit to viewport\r\n                padding: 10, // fit padding\r\n                boundingBox: { x1, y1, w, h }, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\r\n                animate: true, // whether to transition the node positions\r\n                animationDuration: 5, // duration of animation in ms if enabled\r\n                animationEasing: undefined, // easing of animation if enabled\r\n                radius: 105,\r\n                animateFilter: function (node, i) { return true; },\r\n                ready: undefined, // callback on layoutready\r\n                stop: undefined, // callback on layoutstop\r\n                nodeSeparation: 4,\r\n                transform: function (node, position) { return position; } // transform a given node position. Useful for changing flow direction in discrete layouts \r\n            };\r\n\r\n            if (subGraph) {\r\n                y1 -= 10;\r\n                x1 -= 5;\r\n                layout.boundingBox = { x1, y1, w, h };\r\n                if (displayDP) {\r\n                    return (\r\n                        <Grid.Row> A subgraph of 5 nodes is displayed below. Displayed Policy: Differential Privacy\r\n                            <CytoscapeComponent\r\n                                elements={nodesEdges}\r\n                                style={{ width: this.state.w, height: this.state.h }}\r\n                                cy={(cy) => { this.cy = cy }}\r\n                                layout={layout}\r\n                            />\r\n                        </Grid.Row>\r\n                    )\r\n                } else {\r\n                    return (\r\n                        <Grid.Row className=\"policyVisualDesc\"> A subgraph of 5 nodes is displayed below. Displayed Policy: Blowfish Policy\r\n                            <CytoscapeComponent\r\n                                elements={nodesEdges}\r\n                                style={{ width: this.state.w, height: this.state.h }}\r\n                                cy={(cy) => { this.cy = cy }}\r\n                                layout={layout}\r\n                            />\r\n                        </Grid.Row>\r\n                    )\r\n                }\r\n            } else {\r\n                // THIS WILL BE CALLED TWICE BECAUSE REACT JS's NATURE, NEED TO FIX LATER\r\n                if (displayDP) {\r\n                    return (\r\n                        <Grid.Row className=\"policyVisualDesc\"> Displayed Policy: Differential Privacy\r\n                            <CytoscapeComponent\r\n                                elements={nodesEdges}\r\n                                style={{ width: this.state.w, height: this.state.h }}\r\n                                cy={(cy) => { this.cy = cy }}\r\n                                layout={layout}\r\n                            />\r\n                        </Grid.Row>\r\n                    )\r\n                } else {\r\n                    return (\r\n                        <Grid.Row className=\"policyVisualDesc\"> Displayed Policy: Blowfish Policy\r\n                            <CytoscapeComponent\r\n                                elements={nodesEdges}\r\n                                style={{ width: this.state.w, height: this.state.h }}\r\n                                cy={(cy) => { this.cy = cy }}\r\n                                layout={layout}\r\n                            />\r\n                        </Grid.Row>\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        // const layout = {\r\n        //     name: 'circle',\r\n\r\n        //     fit: false, // whether to fit to viewport\r\n        //     padding: 10, // fit padding\r\n        //     boundingBox: { x1, y1, w, h }, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\r\n        //     animate: true, // whether to transition the node positions\r\n        //     animationDuration: 500, // duration of animation in ms if enabled\r\n        //     animationEasing: undefined, // easing of animation if enabled\r\n        //     radius: 105,\r\n        //     animateFilter: function (node, i) { return true; },\r\n        //     ready: undefined, // callback on layoutready\r\n        //     stop: undefined, // callback on layoutstop\r\n        //     nodeSeparation: 4,\r\n        //     transform: function (node, position) { return position; } // transform a given node position. Useful for changing flow direction in discrete layouts \r\n        // };\r\n\r\n        // if (subGraph) {\r\n        //     return (\r\n        //         <Grid>\r\n        //             <Grid.Row className='attr'></Grid.Row>\r\n        //             <Grid.Row>\r\n        //                 <CytoscapeComponent\r\n        //                     elements={nodesEdges}\r\n        //                     style={{ width: this.state.w, height: this.state.h }}\r\n        //                     cy={(cy) => { this.cy = cy }}\r\n        //                     layout={layout}\r\n        //                 />\r\n        //             </Grid.Row>\r\n        //         </Grid>\r\n        //     )\r\n        // } else {\r\n        //     return (\r\n        //         <CytoscapeComponent\r\n        //             elements={nodesEdges}\r\n        //             style={{ width: this.state.w, height: this.state.h }}\r\n        //             cy={(cy) => { this.cy = cy }}\r\n        //             layout={layout}\r\n        //         />\r\n        //     )\r\n        // }\r\n    }\r\n}\r\n\r\nexport default PolicyGraph;","C:\\Users\\Jerry\\blowfish-interface\\src\\components\\Schema.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\AnalystPanel.js",[],"C:\\Users\\Jerry\\blowfish-interface\\src\\components\\analystTable.js",["50","51"],"import React from 'react'\r\nimport styled from 'styled-components'\r\nimport { useTable, useRowSelect } from 'react-table'\r\nimport { Grid } from 'semantic-ui-react';\r\nimport CanvasJSReact from './canvasjs.react';\r\n\r\nconst Styles = styled.div`\r\n  padding: 1rem;\r\n\r\n  table {\r\n    border-spacing: 0;\r\n    border: 1px solid black;\r\n    width: 570px;\r\n    \r\n    tr {\r\n      :last-child {\r\n        td {\r\n          border-bottom: 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    th,\r\n    td {\r\n      margin: 0;\r\n      padding: 0.3rem;\r\n      border-bottom: 1px solid black;\r\n      border-right: 1px solid black;\r\n\r\n      :last-child {\r\n        border-right: 0;\r\n      }\r\n    }\r\n  }\r\n`\r\n\r\nconst IndeterminateCheckbox = React.forwardRef(\r\n    ({ indeterminate, ...rest }, ref) => {\r\n        const defaultRef = React.useRef()\r\n        const resolvedRef = ref || defaultRef\r\n\r\n        React.useEffect(() => {\r\n            resolvedRef.current.indeterminate = indeterminate\r\n        }, [resolvedRef, indeterminate])\r\n\r\n        return (\r\n            <>\r\n                <input type=\"checkbox\" ref={resolvedRef} {...rest} />\r\n            </>\r\n        )\r\n    }\r\n)\r\n\r\nfunction computeGranularity(queryGranularity, lowerBound, upperBound) {\r\n    // console.log('Parameters:', queryGranularity, lowerBound, upperBound)\r\n    let selectedGranu = queryGranularity;\r\n    // sanity check, assign defaut to be 1 if null\r\n    if (selectedGranu === null) {\r\n        selectedGranu = 1\r\n    }\r\n    let granuLabels = [];\r\n    let numEle = Math.ceil((upperBound - lowerBound + 1) / selectedGranu)\r\n    // console.log('this is the number of elements', numEle)\r\n    for (let i = 0; i < numEle; ++i) {\r\n        granuLabels = granuLabels.concat({\r\n            lower: lowerBound + i * selectedGranu,\r\n            upper: lowerBound + (i + 1) * selectedGranu\r\n        })\r\n    }\r\n    // console.log('This is the computed granularity at the end: ', granuLabels)\r\n    return granuLabels;\r\n}\r\n\r\nfunction toggleDataSeries(e) {\r\n    if (typeof (e.dataSeries.visible) === \"undefined\" || e.dataSeries.visible) {\r\n        e.dataSeries.visible = false;\r\n    }\r\n    else {\r\n        e.dataSeries.visible = true;\r\n    }\r\n    this.chart.render();\r\n}\r\n\r\nfunction displayPlots(attrNames, noisyCounts, ranges, granus, workloads) {\r\n    var CanvasJSChart = CanvasJSReact.CanvasJSChart;\r\n    let dataOptions = [];\r\n    for (let i = 0; i < noisyCounts.length; ++i) {\r\n        // console.log(noisyCounts[i], ranges[i], granus[i])\r\n        let noisyAnsPoints = [];\r\n        let noisyAnsPoints1 = [];\r\n        const noisyCount = noisyCounts[i].data;\r\n        const granularity = granus[i];\r\n        const lower = ranges[i].lower;\r\n        const upper = ranges[i].upper;\r\n        // let noisyCounts = this.state.noisyRes;\r\n        const granularityLabels = computeGranularity(granularity, lower, upper);\r\n        if (Array.isArray(noisyCount)) {\r\n            const numPredicates = noisyCount.length;\r\n            if (numPredicates === granularityLabels.length) {\r\n                for (let j = 0; j < numPredicates; ++j) {\r\n                    let y = 0;\r\n                    const x = (granularityLabels[j].lower + granularityLabels[j].upper) / 2\r\n                    if (noisyCount[j] >= 0) {\r\n                        y = noisyCount[j];\r\n                    }\r\n                    noisyAnsPoints = noisyAnsPoints.concat(\r\n                        {\r\n                            x: x,\r\n                            // label: granularityLabels[i].lower.toString() + \"<=\" + attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                            y: y\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n        } else {\r\n            const noisyCount1 = noisyCount.attr1;\r\n            const noisyCount2 = noisyCount.attr2;\r\n            const numPredicates = noisyCount1.length;\r\n            for (let i = 0; i < numPredicates; ++i) {\r\n                let y = 0;\r\n                let y1 = 0;\r\n                const x = (granularityLabels[i].lower + granularityLabels[i].upper) / 2\r\n                if (noisyCount1[i] >= 0) {\r\n                    y = noisyCount1[i];\r\n                }\r\n                if (noisyCount2[i] >= 0) {\r\n                    y1 = noisyCount2[i];\r\n                }\r\n                noisyAnsPoints = noisyAnsPoints.concat(\r\n                    {\r\n                        x: x,\r\n                        // label: attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                        y: y\r\n                    }\r\n                )\r\n                noisyAnsPoints1 = noisyAnsPoints1.concat(\r\n                    {\r\n                        x: x,\r\n                        // label: attrName + \"<\" + granularityLabels[i].upper.toString(),\r\n                        y: y1\r\n                    }\r\n                )\r\n            }\r\n        }\r\n        // console.log(numPredicates)\r\n        // console.log('This is the granularity labels:', granularityLabels)\r\n        // console.log('This is the granularity labels length:', this.state.noisyRes)\r\n        console.log('This is the datapoints', noisyAnsPoints)\r\n        let options = {\r\n            height: 250,\r\n            width: 275,\r\n            animationEnabled: true,\r\n            exportEnabled: true,\r\n            theme: \"light2\", //\"light1\", \"dark1\", \"dark2\"\r\n            title: {\r\n                text: 'Noisy Counts',\r\n                fontSize: 15\r\n            },\r\n            axisX: {\r\n                labelAngle: 50,\r\n                minimum: lower,\r\n                maximum: upper\r\n            },\r\n            axisY: {\r\n                includeZero: true\r\n            },\r\n            toolTip: {\r\n                shared: true\r\n            },\r\n            legend: {\r\n                cursor: \"pointer\",\r\n                itemclick: toggleDataSeries\r\n            },\r\n            data: [{\r\n                type: \"column\", //change type to bar, line, area, pie, etc\r\n                //indexLabel: \"{y}\", //Shows y value on all Data Points\r\n                name: attrNames[i].attrName,\r\n                showInLegend: true,\r\n                indexLabelFontColor: \"#5A5757\",\r\n                indexLabelPlacement: \"outside\",\r\n                color: \"#6D78AD\",\r\n                dataPoints: noisyAnsPoints\r\n            }]\r\n        }\r\n\r\n        console.log(\"This is the workloads\", workloads);\r\n        if (workloads[i] === '1D-Histogram') {\r\n            options.title.text = 'Noisy Counts (Histogram)'\r\n        } else if (workloads[i] === '1D-Cumulative') {\r\n            options.title.text = 'Noisy Counts (Cumulative)'\r\n        } else {\r\n            // This is the 2 dimensional case\r\n            options.title.text = 'Noisy Counts (2D Histogram)'\r\n            options.data = [\r\n                {\r\n                    type: \"column\",\r\n                    name: \"Female\",  // hardcoded here, need to be changed later\r\n                    showInLegend: true,\r\n                    yValueFormatString: \"#,##0.##\",\r\n                    dataPoints: noisyAnsPoints\r\n                },\r\n                {\r\n                    type: \"column\",\r\n                    name: \"Male\",\r\n                    showInLegend: true,\r\n                    yValueFormatString: \"#,##0.##\",\r\n                    dataPoints: noisyAnsPoints1\r\n                }\r\n            ]\r\n        }\r\n        dataOptions = dataOptions.concat(options);\r\n    }\r\n    console.log(dataOptions);\r\n    if (dataOptions.length === 1) {\r\n        return (\r\n            <Grid.Column style={{ width: 300 }}>\r\n                <div className=\"analystNoisyResult\">\r\n                    <CanvasJSChart options={dataOptions[0]}\r\n                    /* onRef={ref => this.chart = ref} */\r\n                    />\r\n                    {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                </div>\r\n            </Grid.Column>\r\n        )\r\n    } else if (dataOptions.length === 2) {\r\n        return (\r\n            <Grid>\r\n                <Grid.Column style={{ width: 300 }}>\r\n                    <div className=\"analystNoisyResult\">\r\n                        <CanvasJSChart options={dataOptions[0]}\r\n                        /* onRef={ref => this.chart = ref} */\r\n                        />\r\n                        {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                    </div>\r\n                </Grid.Column>\r\n                <Grid.Column style={{ width: 300 }}>\r\n                    <div className=\"analystNoisyResult\">\r\n                        <CanvasJSChart options={dataOptions[1]}\r\n                        /* onRef={ref => this.chart = ref} */\r\n                        />\r\n                        {/*You can get reference to the chart instance as shown above using onRef. This allows you to access all chart properties and methods*/}\r\n                    </div>\r\n                </Grid.Column>\r\n            </Grid>\r\n        )\r\n    } else if (dataOptions.length > 2) {\r\n        alert(\"Please select at most 2 records\")\r\n    }\r\n}\r\n\r\nfunction ConstructTable({ columns, data, counts }) {\r\n    // Use the state and functions returned from useTable to build your UI\r\n    const {\r\n        getTableProps,\r\n        getTableBodyProps,\r\n        headerGroups,\r\n        rows,\r\n        prepareRow,\r\n        selectedFlatRows,\r\n        state: { selectedRowIds },\r\n    } = useTable(\r\n        {\r\n            columns,\r\n            data,\r\n        },\r\n        useRowSelect,\r\n        hooks => {\r\n            hooks.visibleColumns.push(columns => [\r\n                // Let's make a column for selection\r\n                {\r\n                    id: 'selection',\r\n                    // The header can use the table's getToggleAllRowsSelectedProps method\r\n                    // to render a checkbox\r\n                    Header: ({ getToggleAllRowsSelectedProps }) => (\r\n                        <div>\r\n                            <IndeterminateCheckbox {...getToggleAllRowsSelectedProps()} />\r\n                        </div>\r\n                    ),\r\n                    // The cell can use the individual row's getToggleRowSelectedProps method\r\n                    // to the render a checkbox\r\n                    Cell: ({ row }) => (\r\n                        <div>\r\n                            <IndeterminateCheckbox {...row.getToggleRowSelectedProps()} />\r\n                        </div>\r\n                    ),\r\n                },\r\n                ...columns,\r\n            ])\r\n        }\r\n    )\r\n\r\n    // console.log(selectedRowIds)\r\n    // variables for graphs\r\n    let noisyCountsIndex = [];\r\n    let noisyCounts = [];\r\n    let ranges = [];\r\n    let granu = [];\r\n    let workloads = [];\r\n    let attrNames = []\r\n    selectedFlatRows.map(\r\n        d => {\r\n            noisyCountsIndex = noisyCountsIndex.concat(d.original.col1)\r\n        }\r\n    )\r\n    for (let i = 0; i < noisyCountsIndex.length; ++i) {\r\n        attrNames = attrNames.concat({\r\n            attrName: counts[noisyCountsIndex[i] - 1].attrName\r\n        })\r\n        noisyCounts = noisyCounts.concat({\r\n            data: counts[noisyCountsIndex[i] - 1].data\r\n        })\r\n        ranges = ranges.concat({\r\n            lower: counts[noisyCountsIndex[i] - 1].range.lower,\r\n            upper: counts[noisyCountsIndex[i] - 1].range.upper\r\n        })\r\n        granu = granu.concat(counts[noisyCountsIndex[i] - 1].granularity)\r\n        workloads = workloads.concat(counts[noisyCountsIndex[i] - 1].workload)\r\n    }\r\n    return (\r\n        <Grid columns={1}>\r\n            <Grid.Row className=\"privacyBudget\">\r\n                The query results will be summarized in the table below\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultTable\">\r\n                <Styles>\r\n                    <table {...getTableProps()}>\r\n                        <thead>\r\n                            {headerGroups.map(headerGroup => (\r\n                                <tr {...headerGroup.getHeaderGroupProps()}>\r\n                                    {headerGroup.headers.map(column => (\r\n                                        <th {...column.getHeaderProps()}>{column.render('Header')}</th>\r\n                                    ))}\r\n                                </tr>\r\n                            ))}\r\n                        </thead>\r\n                        <tbody {...getTableBodyProps()}>\r\n                            {rows.slice(0, 10).map((row, i) => {\r\n                                prepareRow(row)\r\n                                return (\r\n                                    <tr {...row.getRowProps()}>\r\n                                        {row.cells.map(cell => {\r\n                                            return <td {...cell.getCellProps()}>{cell.render('Cell')}</td>\r\n                                        })}\r\n                                    </tr>\r\n                                )\r\n                            })}\r\n                        </tbody>\r\n                    </table>\r\n                </Styles>\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultComparisonDesc\">\r\n                Please select at most 2 records for comparison\r\n            </Grid.Row>\r\n            <Grid.Row className=\"resultComparison\">\r\n                {displayPlots(attrNames, noisyCounts, ranges, granu, workloads)}\r\n            </Grid.Row>\r\n        </Grid>\r\n    )\r\n}\r\n\r\nfunction Table(dataRecord) {\r\n    const record = dataRecord.dataRecord;\r\n    let data = [];\r\n    for (let i = 0; i < record.length; ++i) {\r\n        data = data.concat({\r\n            col1: record[i].index,\r\n            col2: record[i].attrName,\r\n            col3: record[i].workload,\r\n            col4: record[i].granularity,\r\n            col5: record[i].alpha,\r\n            col6: record[i].beta,\r\n            col7: record[i].epsilon,\r\n            col8: record[i].remainingBudget,\r\n        })\r\n    }\r\n\r\n    const columns = [\r\n        {\r\n            Header: 'Query Ind.',\r\n            accessor: 'col1', // accessor is the \"key\" in the data\r\n        },\r\n        {\r\n            Header: 'Attribute',\r\n            accessor: 'col2', // accessor is the \"key\" in the data\r\n        },\r\n        {\r\n            Header: 'Workload Type',\r\n            accessor: 'col3',\r\n        },\r\n        {\r\n            Header: 'Granularity',\r\n            accessor: 'col4',\r\n        },\r\n        {\r\n            Header: 'Alpha',\r\n            accessor: 'col5',\r\n        },\r\n        {\r\n            Header: 'Beta',\r\n            accessor: 'col6',\r\n        },\r\n        {\r\n            Header: 'Privacy Cost',\r\n            accessor: 'col7',\r\n        },\r\n        {\r\n            Header: 'Remaining Budget',\r\n            accessor: 'col8',\r\n        }\r\n    ]\r\n    return (\r\n        <ConstructTable columns={columns} data={data} counts={record} />\r\n    )\r\n}\r\n\r\n\r\nexport default Table;",{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","severity":1,"message":"57","line":1,"column":1,"nodeType":"58","messageId":"59","fix":"60"},{"ruleId":"61","severity":1,"message":"62","line":8,"column":5,"nodeType":"63","messageId":"64","endLine":10,"endColumn":6},{"ruleId":"65","severity":1,"message":"66","line":260,"column":18,"nodeType":"67","messageId":"68","endLine":260,"endColumn":32},{"ruleId":"69","severity":1,"message":"70","line":301,"column":11,"nodeType":"71","messageId":"72","endLine":301,"endColumn":13},"no-native-reassign",["73"],"no-negated-in-lhs",["74"],"unicode-bom","Unexpected Unicode BOM (Byte Order Mark).","Program","unexpected",{"range":"75","text":"76"},"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-unused-vars","'selectedRowIds' is assigned a value but never used.","Identifier","unusedVar","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation",[-1,0],""]